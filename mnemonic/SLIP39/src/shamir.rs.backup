//! Shamir Secret Sharing Implementation for SLIP-39
//!
//! This module implements Shamir's Secret Sharing over GF(256) using
//! Lagrange interpolation for reconstruction.
//!
//! For threshold > 1, implements digest-based verification per SLIP-39 spec.

use rand::Rng;
use zeroize::Zeroize;
use hmac::{Hmac, Mac};
use sha2::Sha256;

use crate::error::{Result, Slip39Error};

/// Digest length in bytes (used for threshold > 1)
const DIGEST_LENGTH_BYTES: usize = 4;

/// Special indices for base shares in threshold > 1 case
const DIGEST_INDEX: u8 = 254;
const SECRET_INDEX: u8 = 255;

/// GF(256) element for Shamir Secret Sharing
#[derive(Debug, Clone, Copy, PartialEq, Eq, Zeroize)]
pub struct GF256(pub u8);

/// Irreducible polynomial for GF(256): x^8 + x^4 + x^3 + x + 1 (0x11B)
const IRREDUCIBLE_POLY: u16 = 0x11B;

impl GF256 {
    /// Zero element
    pub const ZERO: Self = GF256(0);

    /// One element
    pub const ONE: Self = GF256(1);

    /// Create a new GF256 element
    #[inline]
    pub const fn new(value: u8) -> Self {
        GF256(value)
    }

    /// Get the underlying u8 value
    #[inline]
    pub const fn value(self) -> u8 {
        self.0
    }

    /// Addition in GF(256) - XOR
    #[inline]
    pub fn add(self, other: Self) -> Self {
        GF256(self.0 ^ other.0)
    }

    /// Subtraction in GF(256) - same as addition
    #[inline]
    pub fn sub(self, other: Self) -> Self {
        self.add(other)
    }

    /// Multiplication in GF(256)
    pub fn mul(self, other: Self) -> Self {
        if self.0 == 0 || other.0 == 0 {
            return GF256::ZERO;
        }

        let mut result = 0u16;
        let mut a = self.0 as u16;
        let mut b = other.0 as u16;

        for _ in 0..8 {
            if b & 1 != 0 {
                result ^= a;
            }
            b >>= 1;

            let carry = a & 0x80;
            a <<= 1;

            if carry != 0 {
                a ^= IRREDUCIBLE_POLY;
            }
        }

        GF256((result & 0xFF) as u8)
    }

    /// Division in GF(256)
    pub fn div(self, other: Self) -> Option<Self> {
        if other.0 == 0 {
            return None;
        }
        Some(self.mul(other.inverse()?))
    }

    /// Multiplicative inverse using Extended Euclidean Algorithm
    pub fn inverse(self) -> Option<Self> {
        if self.0 == 0 {
            return None;
        }

        let mut t = 0u16;
        let mut new_t = 1u16;
        let mut r = IRREDUCIBLE_POLY;
        let mut new_r = self.0 as u16;

        while new_r != 0 {
            let quotient = gf256_divide_poly(r, new_r);

            let temp_t = t;
            t = new_t;
            new_t = temp_t ^ gf256_multiply_poly(quotient, new_t);

            let temp_r = r;
            r = new_r;
            new_r = temp_r ^ gf256_multiply_poly(quotient, new_r);
        }

        Some(GF256((t & 0xFF) as u8))
    }

    /// Power function
    pub fn pow(self, exp: u32) -> Self {
        if exp == 0 {
            return GF256::ONE;
        }

        let mut result = GF256::ONE;
        let mut base = self;
        let mut e = exp;

        while e > 0 {
            if e & 1 != 0 {
                result = result.mul(base);
            }
            base = base.mul(base);
            e >>= 1;
        }

        result
    }
}

fn gf256_divide_poly(dividend: u16, divisor: u16) -> u16 {
    if divisor == 0 {
        return 0;
    }

    let mut quotient = 0u16;
    let mut remainder = dividend;
    let divisor_degree = 15 - divisor.leading_zeros();

    while remainder != 0 {
        let remainder_degree = 15 - remainder.leading_zeros();
        if remainder_degree < divisor_degree {
            break;
        }

        let shift = remainder_degree - divisor_degree;
        quotient ^= 1u16 << shift;
        remainder ^= divisor << shift;
    }

    quotient
}

fn gf256_multiply_poly(a: u16, b: u16) -> u16 {
    let mut result = 0u16;
    let mut multiplicand = a;
    let mut multiplier = b;

    while multiplier != 0 {
        if multiplier & 1 != 0 {
            result ^= multiplicand;
        }
        multiplicand <<= 1;
        multiplier >>= 1;
    }

    result
}

/// Shamir Secret Sharing implementation for SLIP-39
#[derive(Debug)]
pub struct ShamirSecretSharing;

impl ShamirSecretSharing {
    /// Create digest for threshold > 1 case
    fn create_digest(random_part: &[u8], secret: &[u8]) -> Vec<u8> {
        let mut mac = Hmac::<Sha256>::new_from_slice(random_part)
            .expect("HMAC can take key of any size");
        mac.update(secret);
        let result = mac.finalize();
        result.into_bytes()[..DIGEST_LENGTH_BYTES].to_vec()
    }

    /// Split a secret into n shares with threshold t
    ///
    /// # Arguments
    /// * `secret` - The secret to split
    /// * `threshold` - Minimum shares required to reconstruct (t)
    /// * `share_count` - Total number of shares to create (n)
    /// * `x_coords` - X-coordinates for shares (must be unique and non-zero)
    ///
    /// # Returns
    /// Vector of share values corresponding to x_coords
    ///
    /// # SLIP-39 Digest-Based SSS
    /// For threshold == 1: all shares are copies of the secret
    /// For threshold > 1: uses digest-based verification with base shares
    pub fn split(
        secret: &[u8],
        threshold: u8,
        share_count: u8,
        x_coords: &[u8],
    ) -> Result<Vec<Vec<u8>>> {
        if threshold < 1 {
            return Err(Slip39Error::InvalidThreshold(
                "Threshold must be at least 1".to_string(),
            ));
        }

        if share_count < threshold {
            return Err(Slip39Error::InvalidThreshold(format!(
                "Share count ({}) must be >= threshold ({})",
                share_count, threshold
            )));
        }

        if x_coords.len() != share_count as usize {
            return Err(Slip39Error::InvalidShareData(format!(
                "X-coordinates length ({}) must match share count ({})",
                x_coords.len(),
                share_count
            )));
        }

        // Verify x_coords are unique and non-zero
        for (i, &x) in x_coords.iter().enumerate() {
            if x == 0 {
                return Err(Slip39Error::InvalidShareData(
                    "X-coordinate cannot be zero".to_string(),
                ));
            }

            for &other_x in &x_coords[i + 1..] {
                if x == other_x {
                    return Err(Slip39Error::InvalidShareData(
                        "X-coordinates must be unique".to_string(),
                    ));
                }
            }
        }

        // SLIP-39: If threshold is 1, all shares are identical
        if threshold == 1 {
            return Ok(vec![secret.to_vec(); share_count as usize]);
        }

        // For threshold > 1: use digest-based SSS
        let random_share_count = (threshold - 2) as usize;

        // Generate random shares
        let mut rng = rand::thread_rng();
        let mut base_shares: Vec<(u8, Vec<u8>)> = Vec::new();

        for i in 0..random_share_count {
            let random_share: Vec<u8> = (0..secret.len()).map(|_| rng.gen()).collect();
            base_shares.push((i as u8, random_share));
        }

        // Generate random part and digest
        let random_part: Vec<u8> = (0..secret.len() - DIGEST_LENGTH_BYTES)
            .map(|_| rng.gen())
            .collect();
        let digest = Self::create_digest(&random_part, secret);

        // Create digest share (digest + random_part)
        let mut digest_share = digest.clone();
        digest_share.extend_from_slice(&random_part);
        base_shares.push((DIGEST_INDEX, digest_share));

        // Create secret share
        base_shares.push((SECRET_INDEX, secret.to_vec()));

        // Now interpolate to create the actual shares
        let mut shares = Vec::new();
        for &x in x_coords {
            let share_value = Self::interpolate_share(&base_shares, x)?;
            shares.push(share_value);
        }

        Ok(shares)
    }

    /// Interpolate a share value at point x using base shares
    fn interpolate_share(base_shares: &[(u8, Vec<u8>)], x: u8) -> Result<Vec<u8>> {
        let secret_len = base_shares[0].1.len();
        let mut result = vec![0u8; secret_len];

        // For each byte position
        for byte_idx in 0..secret_len {
            let byte_shares: Vec<_> = base_shares
                .iter()
                .map(|(x_coord, share)| (*x_coord, share[byte_idx]))
                .collect();

            result[byte_idx] = Self::interpolate_byte(&byte_shares, x);
        }

        Ok(result)
    }

    /// Interpolate a single byte at point x using Lagrange interpolation
    fn interpolate_byte(points: &[(u8, u8)], x: u8) -> u8 {
        let mut result = GF256::ZERO;

        for (i, &(x_i, y_i)) in points.iter().enumerate() {
            let mut basis = GF256::new(y_i);

            for (j, &(x_j, _)) in points.iter().enumerate() {
                if i != j {
                    let numerator = GF256::new(x).sub(GF256::new(x_j));
                    let denominator = GF256::new(x_i).sub(GF256::new(x_j));

                    if let Some(denom_inv) = denominator.inverse() {
                        basis = basis.mul(numerator.mul(denom_inv));
                    }
                }
            }

            result = result.add(basis);
        }

        result.value()
    }

    /// Split a single byte using polynomial (old simple method)
    fn split_byte(secret_byte: u8, threshold: u8, x_coords: &[u8]) -> Result<Vec<u8>> {
        }

        Ok(shares)
    }

    /// Split a single byte into shares
    fn split_byte(secret: u8, threshold: u8, x_coords: &[u8]) -> Result<Vec<u8>> {
        let mut rng = rand::thread_rng();

        // Generate random polynomial coefficients: f(x) = secret + a1*x + a2*x^2 + ...
        let mut coeffs = vec![GF256::new(secret)];

        for _ in 1..threshold {
            coeffs.push(GF256::new(rng.gen::<u8>()));
        }

        // Evaluate polynomial at each x-coordinate
        let mut shares = Vec::with_capacity(x_coords.len());

        for &x in x_coords {
            let y = Self::evaluate_polynomial(&coeffs, GF256::new(x));
            shares.push(y.value());
        }

        Ok(shares)
    }

    /// Evaluate polynomial at point x using Horner's method
    fn evaluate_polynomial(coeffs: &[GF256], x: GF256) -> GF256 {
        let mut result = GF256::ZERO;

        for &coeff in coeffs.iter().rev() {
            result = result.mul(x).add(coeff);
        }

        result
    }

    /// Reconstruct secret from shares using Lagrange interpolation
    ///
    /// # Arguments
    /// * `shares` - List of (x, y) share pairs
    ///
    /// # Returns
    /// Reconstructed secret
    pub fn reconstruct(shares: &[(u8, Vec<u8>)]) -> Result<Vec<u8>> {
        if shares.is_empty() {
            return Err(Slip39Error::InsufficientShares {
                have: 0,
                need: 1,
            });
        }

        // Verify all shares have same length
        let secret_len = shares[0].1.len();
        for (_, share_value) in shares {
            if share_value.len() != secret_len {
                return Err(Slip39Error::IncompatibleShares(
                    "All shares must have the same length".to_string(),
                ));
            }
        }

        let mut secret = vec![0u8; secret_len];

        // Reconstruct each byte independently
        for byte_idx in 0..secret_len {
            let byte_shares: Vec<(u8, u8)> = shares
                .iter()
                .map(|(x, y)| (*x, y[byte_idx]))
                .collect();

            secret[byte_idx] = Self::reconstruct_byte(&byte_shares)?;
        }

        Ok(secret)
    }

    /// Reconstruct a single byte using Lagrange interpolation at x=0
    fn reconstruct_byte(shares: &[(u8, u8)]) -> Result<u8> {
        let mut result = GF256::ZERO;

        // Lagrange interpolation: f(0) = Σ y_j * L_j(0)
        for (j, &(x_j, y_j)) in shares.iter().enumerate() {
            // Calculate Lagrange basis polynomial L_j(0)
            let mut basis = GF256::ONE;

            for (m, &(x_m, _)) in shares.iter().enumerate() {
                if j == m {
                    continue;
                }

                // L_j(0) *= (0 - x_m) / (x_j - x_m)
                // In GF(256): (0 - x_m) = x_m (since subtraction is XOR)
                let numerator = GF256::new(x_m);
                let denominator = GF256::new(x_j ^ x_m);

                if let Some(inv) = denominator.inverse() {
                    basis = basis.mul(numerator).mul(inv);
                } else {
                    return Err(Slip39Error::GroupReconstructionFailed(
                        "Division by zero in Lagrange interpolation".to_string(),
                    ));
                }
            }

            result = result.add(GF256::new(y_j).mul(basis));
        }

        Ok(result.value())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_gf256_arithmetic() {
        let a = GF256::new(0x53);
        let b = GF256::new(0xCA);

        // Test addition (XOR)
        assert_eq!(a.add(b).value(), 0x53 ^ 0xCA);

        // Test multiplication identity
        assert_eq!(a.mul(GF256::ONE), a);

        // Test zero
        assert_eq!(a.mul(GF256::ZERO), GF256::ZERO);
    }

    #[test]
    fn test_gf256_inverse() {
        for i in 1..=255u8 {
            let a = GF256::new(i);
            if let Some(inv) = a.inverse() {
                assert_eq!(a.mul(inv), GF256::ONE);
            }
        }
    }

    #[test]
    fn test_shamir_split_reconstruct() {
        let secret = vec![0x01, 0x02, 0x03, 0x04];
        let threshold = 3;
        let share_count = 5;
        let x_coords = vec![1, 2, 3, 4, 5];

        // Split
        let shares = ShamirSecretSharing::split(&secret, threshold, share_count, &x_coords).unwrap();

        // Reconstruct with exactly threshold shares
        let share_subset: Vec<(u8, Vec<u8>)> = shares
            .iter()
            .take(threshold as usize)
            .enumerate()
            .map(|(i, s)| (x_coords[i], s.clone()))
            .collect();

        let reconstructed = ShamirSecretSharing::reconstruct(&share_subset).unwrap();
        assert_eq!(reconstructed, secret);
    }

    #[test]
    fn test_shamir_any_threshold_shares() {
        let secret = vec![0xAA, 0xBB, 0xCC];
        let threshold = 3;
        let share_count = 5;
        let x_coords = vec![1, 2, 3, 4, 5];

        let shares = ShamirSecretSharing::split(&secret, threshold, share_count, &x_coords).unwrap();

        // Try different combinations of threshold shares
        let combinations = vec![
            vec![0, 1, 2],
            vec![0, 2, 4],
            vec![1, 3, 4],
            vec![2, 3, 4],
        ];

        for combo in combinations {
            let share_subset: Vec<(u8, Vec<u8>)> = combo
                .iter()
                .map(|&i| (x_coords[i], shares[i].clone()))
                .collect();

            let reconstructed = ShamirSecretSharing::reconstruct(&share_subset).unwrap();
            assert_eq!(reconstructed, secret);
        }
    }

    #[test]
    fn test_shamir_insufficient_shares() {
        let secret = vec![0x01, 0x02];
        let threshold = 3;
        let x_coords = vec![1, 2, 3, 4];

        let shares = ShamirSecretSharing::split(&secret, threshold, 4, &x_coords).unwrap();

        // Try with only 2 shares (less than threshold)
        let insufficient: Vec<(u8, Vec<u8>)> = shares
            .iter()
            .take(2)
            .enumerate()
            .map(|(i, s)| (x_coords[i], s.clone()))
            .collect();

        let reconstructed = ShamirSecretSharing::reconstruct(&insufficient).unwrap();

        // Should NOT match original (insufficient shares)
        assert_ne!(reconstructed, secret);
    }

    #[test]
    fn test_shamir_invalid_threshold() {
        let result = ShamirSecretSharing::split(&[0x01], 0, 5, &[1, 2, 3, 4, 5]);
        assert!(result.is_err());

        let result = ShamirSecretSharing::split(&[0x01], 6, 5, &[1, 2, 3, 4, 5]);
        assert!(result.is_err());
    }

    #[test]
    fn test_shamir_zero_x_coordinate() {
        let result = ShamirSecretSharing::split(&[0x01], 2, 3, &[0, 1, 2]);
        assert!(result.is_err());
    }

    #[test]
    fn test_shamir_duplicate_x_coordinates() {
        let result = ShamirSecretSharing::split(&[0x01], 2, 3, &[1, 1, 2]);
        assert!(result.is_err());
    }
}
